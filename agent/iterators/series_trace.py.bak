\
# -*- coding: utf-8 -*-
"""
agent/iterators/series_trace.py
===========================================================
作用：
  带“溯源”的系列自动迭代：
    - 抓最近 N 条视频
    - 抓评论（保存抽样）
    - LLM 产洞察（保存）
    - 仅选“视觉域”的改动（delta），并记录它来自哪一个话题/动作建议
    - 将该改动与若干“代表性评论”建立关联（证据）
    - 合并成新 JSON 提示词（vN+1）
    - 生成可读报告（由 reports 模块完成）

注意：
  - 不修改你现有的 iterate_series_to_new_prompt；这是一个平行增强版本。
"""

import os, json, time
from typing import List, Dict, Any, Tuple
from agent.collectors.bilibili import list_space_videos, fetch_comments, Video
from agent.miners.comments import analyze_comments_to_insight
from agent.iterators.delta_normalizer import normalize_to_visual_deltas
from agent.iterators.merge_policy import apply_deltas
from agent.prompt.schema_json import VideoPromptJSON
from agent.interactive.refiner import save_refined_version
from agent.reports.trace_report import save_trace_bundle

def _load_json(path: str) -> Dict[str, Any]:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def _select_visual_deltas_with_evidence(insight: Dict[str, Any], top_k: int = 3) -> List[Dict[str, Any]]:
    """
    从洞察里挑选“视觉域”的改动，并附上证据：
      返回元素结构：
      {
        "delta": {... merge_policy 可直接用 ...},
        "from_action_text": "<原 action.delta 字符串>",
        "topic_label": "<来自哪个话题>",
        "supporting_quotes": ["评论1","评论2","评论3"]  # 选该话题里的 key_quotes 前3个
      }
    """
    # 先把所有 action 摊平，并带上话题引用
    flat = []
    for t in insight.get("topics", []):
        label = t.get("label") or ""
        topic_quotes = t.get("key_quotes") or []
        for a in t.get("actions", []):
            sc = ((a.get("priority_ice") or {}).get("score") or 0.0)
            flat.append((float(sc), a, label, topic_quotes))

    # 按 score 降序
    flat.sort(key=lambda x: x[0], reverse=True)

    picked = []
    for _, action, label, quotes in flat:
        # 对每个 action 单独做一次归一，确保 1:1 建立映射
        vis = normalize_to_visual_deltas([action], top_k=1)
        if not vis:
            continue
        delta = vis[0]
        picked.append({
            "delta": delta,
            "from_action_text": action.get("delta") or "",
            "topic_label": label,
            "supporting_quotes": list(quotes[:3])
        })
        if len(picked) >= top_k:
            break
    return picked

def iterate_series_with_trace(base_prompt_path: str,
                              space_url: str,
                              filter_keyword: str = "",
                              limit_videos: int = 3,
                              max_comments: int = 200,
                              top_deltas: int = 3) -> Tuple[str, str]:
    """
    带“溯源”的系列自动迭代：
      - 返回：(new_prompt_path, report_path)
    """
    base = _load_json(base_prompt_path)
    _ = VideoPromptJSON(**base)

    videos: List[Video] = list_space_videos(space_url, filter_keyword, limit_videos)
    if not videos:
        raise RuntimeError("未获取到系列视频，请检查空间链接/关键词/风控。")

    trace_items = []  # 用于报告：每条视频的评论、洞察、被采纳的改动及证据
    all_deltas = []

    for v in videos:
        # 1) 抓评论并抽样（我们 miners 已经会在内部做抽样，但这里把抓到的原始评论保存下来）
        comments = fetch_comments(v.bvid, max_comments=max_comments)

        # 2) LLM 产洞察（严格 JSON）
        insight = analyze_comments_to_insight(v, comments)

        # 3) 只取“视觉域”改动，并附上证据（话题 + 代表性 quotes）
        vis_with_evd = _select_visual_deltas_with_evidence(insight, top_k=top_deltas)

        # 记录 trace
        trace_items.append({
            "video": {
                "bvid": v.bvid, "title": v.title, "url": v.url, "pubdate": v.pubdate, "stats": v.stats
            },
            "comments_sampled_count": len(comments),
            "comments_sampled_preview": [c.get("text","") for c in comments[:10]],
            "insight": insight,
            "adopted_deltas": vis_with_evd
        })

        # 收集合并的真正 delta（去掉证据包装）
        for item in vis_with_evd:
            all_deltas.append(item["delta"])

    # 为避免一次改动过多，这里再次截断
    all_deltas = all_deltas[:top_deltas]

    new_json = apply_deltas(base, all_deltas)
    new_path = save_refined_version(new_json, base_json_path=base_prompt_path)

    # 生成报告（JSON + Markdown），返回报告路径
    report_path = save_trace_bundle(
        base_prompt_path=base_prompt_path,
        new_prompt_path=new_path,
        space_url=space_url,
        filter_keyword=filter_keyword,
        trace_items=trace_items
    )
    return new_path, report_path

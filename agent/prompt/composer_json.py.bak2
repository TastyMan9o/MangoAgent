# -*- coding: utf-8 -*-
"""
agent/prompt/composer_json.py
===========================================================
作用：
  用小模型（DeepSeek）把“主题 + 默认值”生成 **英文 JSON Prompt（v1）**。
  - 输出严格匹配 VideoPromptJSON（Pydantic 校验）
  - 强制使用 .env 中的 DEEPSEEK_API_KEY（不回显、不中途打印）
  - 引入“强力规范化”（normalize）：即便模型结构不完全正确，也会自动纠正为合法 JSON
  - 将模型原始输出写入 outputs/runs/last_compose_raw.json 便于排查
"""

import os, json, math
from datetime import datetime
from typing import Dict, Any, List
from dotenv import load_dotenv
from openai import OpenAI
from pydantic import ValidationError

from agent.prompt.schema_json import VideoPromptJSON
from agent.utils.io import write_json, ensure_dir

# 预加载 .env
load_dotenv()

def _series_slug(s: str) -> str:
    """把系列名转为安全的目录名（仅小写字母数字与下划线）"""
    return "".join(ch.lower() if ch.isalnum() else "_" for ch in s).strip("_") or "series"

def _ts() -> str:
    """时间戳：YYYYMMDD_HHMM"""
    return datetime.now().strftime("%Y%m%d_%H%M")

def ds_client() -> OpenAI:
    """创建 DeepSeek 客户端（Key 必须写在 .env 的 DEEPSEEK_API_KEY）"""
    key = os.getenv("DEEPSEEK_API_KEY")
    if not key:
        raise RuntimeError("缺少 DEEPSEEK_API_KEY，请在 .env 中设置你的真实 Key。")
    return OpenAI(api_key=key, base_url="https://api.deepseek.com")

# 系统提示词（指导小模型输出严格 JSON）
SYSTEM_MSG = """你是一个严格的 JSON 提示词生成器。
要求：
- 输出必须是一个合法的 JSON 对象，且完全符合给定的 JSON schema（字段、类型）。
- 所有文本字段一律使用英文。
- 合理补充必要的细节；保持安全、干净、无真人面孔。
- 若无特殊说明，aspect_ratio 默认为 16:9，person_generation 为 dont_allow。
"""

# 注意：演示占位符使用双花括号转义，避免 .format() 把它当变量
USER_TMPL = """请基于以下输入，生成一个 VideoPromptJSON 对象（仅返回 JSON 本体）：

INPUT:
- TOPIC (English or Chinese): {topic}
- SERIES NAME: {series}
- DEFAULTS: {defaults}

JSON SCHEMA (fields only, not full definition):
- name: string
- meta: {{ source, topic, series, created_at, parent_prompt_id, notes }}
- veo_params: {{ aspect_ratio, person_generation, negative_prompt }}
- prompt: {{
    concept, 
    shots: [{{camera, composition, focal_subject, movement_speed?}}], 
    actions: [string], 
    lighting, style, audio?, 
    timing: {{ duration_seconds, beats: [{{start_sec, end_sec, description}}] }}, 
    constraints: [string]
  }}

规则（VERY IMPORTANT, DO NOT VIOLATE THE KEYS ABOVE）：
- name 形如 "deepseek_chat/{series_slug}/{{YYYYMMDD_HHMM}}_v1"
- meta.source = "hotspot" 或 "manual"（若 topic 来自人工则用 manual）
- meta.created_at 填当前时间（ISO 8601），parent_prompt_id = null
- shots 每个元素必须是对象，至少包含 camera/composition/focal_subject
- beats 每个元素必须是对象，包含 start_sec/end_sec/description（秒为浮点数）
- timing.beats 要与 duration_seconds 合理一致；若为空也允许
- constraints 至少包含：No human faces, No text watermarks, Avoid cartoon rendering
- 仅返回 JSON 对象，不要解释或代码围栏
"""

# ---------------- “强力规范化”函数区 ----------------

def _ensure_defaults(obj: Dict[str, Any], topic: str, series: str):
    """为关键字段做兜底补全：name/meta/veo_params/prompt 空值"""
    obj.setdefault("meta", {})
    obj.setdefault("veo_params", {})
    obj.setdefault("prompt", {})

    series_slug = _series_slug(series)
    # name 兜底
    name = (obj.get("name") or "").strip()
    if not name or not name.startswith("deepseek_chat/"):
        obj["name"] = f"deepseek_chat/{series_slug}/{_ts()}_v1"

    # meta 兜底
    obj["meta"]["series"] = obj["meta"].get("series") or series
    obj["meta"]["topic"] = obj["meta"].get("topic") or topic
    obj["meta"]["created_at"] = obj["meta"].get("created_at") or datetime.now().astimezone().isoformat(timespec="seconds")
    obj["meta"].setdefault("parent_prompt_id", None)

    # veo_params 兜底
    vp = obj["veo_params"]
    vp.setdefault("aspect_ratio", "16:9")
    vp.setdefault("person_generation", "dont_allow")
    vp.setdefault("negative_prompt", "cartoon, drawing, low quality, overexposure, blurry")

    # prompt 兜底
    pr = obj["prompt"]
    pr.setdefault("concept", topic if isinstance(topic, str) else "Video concept")
    pr.setdefault("shots", [])
    pr.setdefault("actions", [])
    pr.setdefault("lighting", "soft key light with gentle rim light")
    pr.setdefault("style", "photorealistic, macro, shallow depth of field")
    pr.setdefault("audio", "subtle ASMR bubble pops, low ambient")
    pr.setdefault("timing", {"duration_seconds": 60.0, "beats": []})
    pr.setdefault("constraints", ["No human faces", "No text watermarks", "Avoid cartoon rendering"])

def _coerce_shot(x: Any, default_subject: str) -> Dict[str, Any]:
    """把任意元素转为合法 Shot 字典"""
    if isinstance(x, dict):
        return {
            "camera": x.get("camera") or x.get("cam") or "macro close-up, slow dolly-in",
            "composition": x.get("composition") or "centered macro composition",
            "focal_subject": x.get("focal_subject") or default_subject,
            "movement_speed": x.get("movement_speed") or "slow"
        }
    # 字符串或其它类型：放到 camera 字段
    txt = str(x).strip()
    return {
        "camera": txt or "macro close-up, slow dolly-in",
        "composition": "centered macro composition",
        "focal_subject": default_subject,
        "movement_speed": "slow"
    }

def _normalize_shots(obj: Dict[str, Any]):
    """规范化 prompt.shots：字符串列表/缺字段 => 合法对象列表"""
    pr = obj.get("prompt", {})
    shots = pr.get("shots", [])
    if not isinstance(shots, list):
        shots = []
    subject = pr.get("concept") or "subject"
    fixed = [_coerce_shot(x, subject) for x in shots]
    pr["shots"] = fixed

def _beats_from_time_action(beats: List[Any], duration: float) -> List[Dict[str, Any]]:
    """把 [{time, action}] 转为 [{start_sec, end_sec, description}]"""
    # 收集 (time, action)
    items: List[tuple] = []
    for b in beats:
        if isinstance(b, dict):
            t = b.get("time") or b.get("t") or b.get("sec")
            a = b.get("action") or b.get("desc") or b.get("description")
            if t is not None and a:
                try:
                    tt = float(t)
                except:
                    continue
                items.append((tt, str(a)))
        elif isinstance(b, (int, float, str)):
            # 字符串/数字也许只是时间，描述缺失则跳过
            try:
                tt = float(b)
                items.append((tt, "action"))
            except:
                pass
    if not items:
        return []
    items.sort(key=lambda x: x[0])
    out: List[Dict[str, Any]] = []
    for i, (t, a) in enumerate(items):
        start = max(0.0, float(t))
        if i + 1 < len(items):
            nxt = float(items[i+1][0])
            end = max(start, nxt - 0.1)
        else:
            end = max(start, float(duration))
        out.append({"start_sec": round(start, 3), "end_sec": round(end, 3), "description": a})
    return out

def _beats_from_strings(beats: List[str], duration: float) -> List[Dict[str, Any]]:
    """把 ['a','b','c'] 均分为时间片"""
    n = max(1, len(beats))
    seg = float(duration) / n
    out = []
    for i, desc in enumerate(beats):
        start = seg * i
        end = seg * (i + 1)
        out.append({"start_sec": round(start, 3), "end_sec": round(end, 3), "description": str(desc)})
    return out

def _normalize_beats(obj: Dict[str, Any]):
    """规范化 prompt.timing.beats：支持多种“错误形态”并矫正"""
    pr = obj.get("prompt", {})
    timing = pr.get("timing", {})
    duration = timing.get("duration_seconds") or 60.0
    try:
        duration = float(duration)
    except:
        duration = 60.0
    beats = timing.get("beats", [])
    if not isinstance(beats, list):
        beats = []

    # 情况 1：已经是合法结构
    ok = True
    for b in beats:
        if not (isinstance(b, dict) and "start_sec" in b and "end_sec" in b and "description" in b):
            ok = False
            break
    if ok:
        # 简单清洗：确保数值类型正确
        fixed = []
        for b in beats:
            try:
                s = float(b["start_sec"]); e = float(b["end_sec"]); d = str(b["description"])
            except:
                continue
            if e < s:
                e = s
            fixed.append({"start_sec": round(s,3), "end_sec": round(e,3), "description": d})
        timing["beats"] = fixed
        pr["timing"] = timing
        obj["prompt"] = pr
        return

    # 情况 2：[{time, action}] 结构
    has_time_action = False
    for b in beats:
        if isinstance(b, dict) and ("time" in b or "t" in b or "sec" in b):
            has_time_action = True
            break
    if has_time_action:
        timing["beats"] = _beats_from_time_action(beats, duration)
        pr["timing"] = timing
        obj["prompt"] = pr
        return

    # 情况 3：字符串列表
    if beats and all(isinstance(x, str) for x in beats):
        timing["beats"] = _beats_from_strings(beats, duration)
        pr["timing"] = timing
        obj["prompt"] = pr
        return

    # 兜底：无 beats，也不强制
    timing["beats"] = []
    pr["timing"] = timing
    obj["prompt"] = pr

def _normalize_all(obj: Dict[str, Any], topic: str, series: str, source: str):
    """一站式规范化：补 defaults → 规范 shots → 规范 beats → 固定 source"""
    _ensure_defaults(obj, topic, series)
    _normalize_shots(obj)
    _normalize_beats(obj)
    obj.setdefault("meta", {})
    obj["meta"]["source"] = source

# ---------------- 主流程 ----------------

def compose_v1_json(topic: str, series: str, defaults: Dict[str, Any], source: str = "hotspot",
                    model: str = "deepseek-chat") -> Dict[str, Any]:
    """
    调用小模型生成一个 v1 的英文 JSON Prompt（若结构异常会自动规范化）。
    """
    client = ds_client()
    series_slug = _series_slug(series)

    user_msg = USER_TMPL.format(
        topic=topic,
        series=series,
        defaults=json.dumps(defaults, ensure_ascii=False),
        series_slug=series_slug
    )

    resp = client.chat.completions.create(
        model=model,
        messages=[{"role": "system", "content": SYSTEM_MSG},
                  {"role": "user", "content": user_msg}],
        temperature=0.2,
    )
    content = resp.choices[0].message.content.strip()

    # 去掉 ```json 围栏（模型有时会自动包裹）
    if content.startswith("```"):
        content = content.strip("`")
        if content.lower().startswith("json"):
            content = content[4:].strip()

    # 保存原始输出，便于排查
    ensure_dir("outputs/runs")
    try:
        raw_path = os.path.join("outputs", "runs", "last_compose_raw.json")
        with open(raw_path, "w", encoding="utf-8") as f:
            f.write(content)
    except Exception:
        pass

    # 解析 JSON
    try:
        obj = json.loads(content)
    except Exception as e:
        raise RuntimeError(f"模型未返回合法 JSON，原始输出已保存到 outputs/runs/last_compose_raw.json") from e

    # 规范化
    _normalize_all(obj, topic=topic, series=series, source=source)

    # 最终校验
    try:
        _ = VideoPromptJSON(**obj)
    except ValidationError as e:
        raise RuntimeError(f"生成的 JSON 不符合 schema（规范化后仍失败）：{e}")

    return obj

def save_v1_json(obj: Dict[str, Any]) -> str:
    """落盘 v1 JSON，返回文件路径（prompts/deepseek_chat/..._v1.json）"""
    name = obj.get("name", "deepseek_chat/untitled/unnamed_v1")
    rel = name.split("/", 1)[-1] + ".json"
    path = os.path.join("prompts", "deepseek_chat", rel)
    ensure_dir(os.path.dirname(path))
    write_json(path, obj)
    return path

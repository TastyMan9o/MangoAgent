\
# -*- coding: utf-8 -*-
"""
agent/interactive/refiner.py  （覆盖版）
===========================================================
变更点：
  - 强化 SYSTEM：严格限定“只改视觉域字段”，忽略封面/标题/互动类建议
  - 增加“字段白名单后置护栏”：若模型越界修改，则回退到仅覆盖白名单字段
"""

import os, json, re, copy
from datetime import datetime
from typing import Tuple, Dict, Any, List
from dotenv import load_dotenv
from openai import OpenAI
from pydantic import ValidationError
from agent.prompt.schema_json import VideoPromptJSON
from agent.utils.io import write_json, ensure_dir

load_dotenv()

def deepseek_client() -> OpenAI:
    key = os.getenv("DEEPSEEK_API_KEY")
    if not key:
        raise RuntimeError("缺少 DEEPSEEK_API_KEY，请在 .env 设置真实值。")
    return OpenAI(api_key=key, base_url="https://api.deepseek.com")

def _now_iso() -> str:
    return datetime.now().astimezone().isoformat(timespec="seconds")

def _read_json(path: str) -> Dict[str, Any]:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def _version_bump_name(base_name: str) -> str:
    import re
    m = re.search(r"(.*)_v(\d+)$", base_name)
    if not m:
        return base_name + "_v2"
    prefix, n = m.group(1), int(m.group(2))
    return f"{prefix}_v{n+1}"

def _json_diff(old: Dict[str, Any], new: Dict[str, Any], path="$") -> List[str]:
    diffs = []
    if type(old) != type(new):
        diffs.append(f"{path}: type {type(old).__name__} -> {type(new).__name__}")
        return diffs
    if isinstance(old, dict):
        keys = set(old) | set(new)
        for k in sorted(keys):
            p = f"{path}.{k}"
            if k not in old:
                diffs.append(f"{p}: <added>")
            elif k not in new:
                diffs.append(f"{p}: <removed>")
            else:
                diffs.extend(_json_diff(old[k], new[k], p))
    elif isinstance(old, list):
        if len(old) != len(new):
            diffs.append(f"{path}: list len {len(old)} -> {len(new)}")
    else:
        if old != new:
            diffs.append(f"{path}: '{old}' -> '{new}'")
    return diffs

# -------- 白名单护栏 --------
_ALLOWED_PREFIXES = [
    "veo_params.aspect_ratio",
    "veo_params.person_generation",
    "veo_params.negative_prompt",
    "prompt.concept",
    "prompt.shots",
    "prompt.actions",
    "prompt.lighting",
    "prompt.style",
    "prompt.audio",
    "prompt.timing",
    "prompt.constraints",
]

def _overlay_allowed(old: Dict[str, Any], new: Dict[str, Any]) -> Dict[str, Any]:
    """只把白名单字段从 new 覆盖到 old，返回新的 dict"""
    out = copy.deepcopy(old)
    # 简单逐条复制（满足我们的字段层次）
    if "veo_params" in new:
        out.setdefault("veo_params", {})
        for k in ["aspect_ratio","person_generation","negative_prompt"]:
            if k in new["veo_params"]:
                out["veo_params"][k] = new["veo_params"][k]
    if "prompt" in new:
        out.setdefault("prompt", {})
        for k in ["concept","shots","actions","lighting","style","audio","timing","constraints"]:
            if k in new["prompt"]:
                out["prompt"][k] = new["prompt"][k]
    return out

REFINE_SYSTEM = (
"你是严格的“视觉域 JSON 提示词改写器”。"
"只允许更新这些字段："
"veo_params.{aspect_ratio,person_generation,negative_prompt}；"
"prompt.{concept,shots,actions,lighting,style,audio,timing,constraints}。"
"禁止添加/修改与封面(thumbnail)、标题(title)、互动(engagement)、描述(description)有关的任何内容。"
"最终必须输出严格 JSON（英文）。"
)

REFINE_USER_TMPL = """CURRENT_PROMPT_JSON:
{current_json}

USER_FEEDBACK (may be CN/EN; keep only VISUAL changes):
{feedback}

RULES:
- Update ONLY visual fields listed in system instruction.
- Ignore any packaging/thumbnail/title/engagement suggestions.
- Keep schema valid; keep other fields identical.
- Return JSON object ONLY (no explanation).
"""

def refine_prompt_json(base_json_path: str, user_feedback: str, model: str = "deepseek-chat") -> Tuple[Dict[str, Any], Dict[str, Any], List[str]]:
    old_obj = _read_json(base_json_path)
    _ = VideoPromptJSON(**old_obj)

    client = deepseek_client()
    user_msg = REFINE_USER_TMPL.format(current_json=json.dumps(old_obj, ensure_ascii=False, indent=2),
                                       feedback=user_feedback)
    resp = client.chat.completions.create(
        model=model,
        messages=[{"role": "system", "content": REFINE_SYSTEM},
                  {"role": "user", "content": user_msg}],
        temperature=0.2,
    )
    content = resp.choices[0].message.content.strip()
    content = re.sub(r"^```json\\s*|\\s*```$", "", content, flags=re.I).strip()
    try:
        new_obj = json.loads(content)
    except json.JSONDecodeError as e:
        raise RuntimeError(f"返回不是合法 JSON：\\n{content}") from e

    # 若模型修改越界：仅保留白名单字段改动
    filtered_obj = _overlay_allowed(old_obj, new_obj)

    try:
        _ = VideoPromptJSON(**filtered_obj)
    except ValidationError as e:
        raise RuntimeError(f"改写后的 JSON 不符合 schema：{e}")

    diffs = _json_diff(old_obj, filtered_obj, "$")
    return old_obj, filtered_obj, diffs

def save_refined_version(new_json: Dict[str, Any], base_json_path: str) -> str:
    name = new_json.get("name") or "deepseek_chat/untitled/unnamed_v1"
    # 自动 +1
    import re
    m = re.search(r"(.*)_v(\\d+)$", name)
    if not m:
        new_name = name + "_v2"
    else:
        prefix, n = m.group(1), int(m.group(2))
        new_name = f"{prefix}_v{n+1}"
    new_json["name"] = new_name
    if "meta" in new_json and isinstance(new_json["meta"], dict):
        new_json["meta"]["created_at"] = _now_iso()

    base_dir = os.path.join("prompts", "deepseek_chat")
    rel = new_name.split("/", 1)[-1] + ".json"
    out_path = os.path.join(base_dir, rel)
    ensure_dir(os.path.dirname(out_path))
    write_json(out_path, new_json)
    return out_path
